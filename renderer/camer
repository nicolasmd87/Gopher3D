// camera.go
package renderer

import (
	"math"

	"github.com/go-gl/mathgl/mgl32"
)

type Camera struct {
	position    mgl32.Vec3
	front       mgl32.Vec3
	up          mgl32.Vec3
	right       mgl32.Vec3
	worldUp     mgl32.Vec3
	yaw, pitch  float32
	speed       float32
	sensitivity float32
	view        mgl32.Mat4
	projection  mgl32.Mat4
}

func NewCamera() *Camera {
	camera := &Camera{
		position:    mgl32.Vec3{1, 0, 100},
		front:       mgl32.Vec3{0, 0, -1},
		worldUp:     mgl32.Vec3{0, 1, 0},
		yaw:         -90.0,
		speed:       0.05,
		sensitivity: 0.1,
	}
	camera.updateCameraVectors()
	return camera
}

func (c *Camera) UpdateProjection(fov, aspectRatio, near, far float32) {
	c.projection = mgl32.Perspective(mgl32.DegToRad(fov), aspectRatio, near, far)
}

func (c *Camera) GetViewProjection() mgl32.Mat4 {
	view := mgl32.LookAtV(c.position, c.position.Add(c.front), c.up)
	return c.projection.Mul4(view)
}

func (c *Camera) ProcessKeyboard(direction string, deltaTime float32) {
	velocity := c.speed * deltaTime
	switch direction {
	case "FORWARD":
		c.position = c.position.Add(c.front.Mul(velocity))
	case "BACKWARD":
		c.position = c.position.Sub(c.front.Mul(velocity))
	case "LEFT":
		c.position = c.position.Sub(c.right.Mul(velocity))
	case "RIGHT":
		c.position = c.position.Add(c.right.Mul(velocity))
	}
}

func (c *Camera) ProcessMouseMovement(xoffset, yoffset float32, constrainPitch bool) {
	xoffset *= c.sensitivity
	yoffset *= c.sensitivity
	c.yaw += xoffset
	c.pitch += yoffset
	if constrainPitch {
		if c.pitch > 89.0 {
			c.pitch = 89.0
		}
		if c.pitch < -89.0 {
			c.pitch = -89.0
		}
	}
	c.updateCameraVectors()
}

func (c *Camera) updateCameraVectors() {
	front := mgl32.Vec3{
		float32(math.Cos(float64(mgl32.DegToRad(c.yaw))) * math.Cos(float64(mgl32.DegToRad(c.pitch)))),
		float32(math.Sin(float64(mgl32.DegToRad(c.pitch)))),
		float32(math.Sin(float64(mgl32.DegToRad(c.yaw))) * math.Cos(float64(mgl32.DegToRad(c.pitch)))),
	}
	c.front = front.Normalize()
	c.right = c.front.Cross(c.worldUp).Normalize()
	c.up = c.right.Cross(c.front).Normalize()
}
